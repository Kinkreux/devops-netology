Домашнее задание к занятию "4.2. Использование Python для решения типовых DevOps задач"
Марина Пустовит

**1. Есть скрипт:**

````
#!/usr/bin/env python3
a = 1
b = '2'
c = a + b
````

* Какое значение будет присвоено переменной c?
 * Нельзя сложить число (a автоматически присвоен int) и строку (b явно присвоена строка). Получим ошибку.

* Как получить для переменной c значение 12?
 * Нужно определить a как строку. Либо явно присвоить 1 в кавычках, либо явно присвоить переменной тип str. Строки конкатенируются, a + b даст 12.

* Как получить для переменной c значение 3?
 * Нужно определить b как int. Присвоить 2 без кавычек, и оно само станет int, или явно присвоить переменной тип int. Тогда a + b будет арифметической операцией и даст 3

**2. Мы устроились на работу в компанию, где раньше уже был DevOps Engineer. Он написал скрипт, позволяющий узнать, какие файлы модифицированы в репозитории, относительно локальных изменений. Этим скриптом недовольно начальство, потому что в его выводе есть не все изменённые файлы, а также непонятен полный путь к директории, где они находятся. Как можно доработать скрипт ниже, чтобы он исполнял требования вашего руководителя?**

````
#!/usr/bin/env python3

import os

bash_command = ["cd ~/netology/sysadm-homeworks", "git status"]
result_os = os.popen(' && '.join(bash_command)).read()
is_change = False
for result in result_os.split('\n'):
    if result.find('modified') != -1:
        prepare_result = result.replace('\tmodified:   ', '')
        print(prepare_result)
        break
        
````

**Ответ:**

Локальные изменения могут быть untracked, modified, staged и committed. Это то, что мы ещё не запушили в удаленный репозиторий (фактически все после последней синхронизации с удаленным репозиторием тем или иным способом).
Причем это могут быть целые ветки и семейства веток, а не только наш последний коммит или то, что случилось после него.  При этом имена веток и проч. неизвестны и могут быть любыми. Игнорируемые файлы тоже, по идее, к нам.
Но если я сейчас прпытаюсь написать команду, которая будет все это получать, то это будет уже что-то монструозное даже без питона и тянет на отдельную задачу со звездочкой.
Так что я допущу, что мы вот только что запушили и надо посмотреть только последние изменения без локальных коммитов и ограничусь добавлением к git status флагов, которые включат в список файлов неотслеживаемые и игнорируемые, а также вернет нормализованный вывод ("для скриптов", как утверждает ман).

Нормализованный вывод дает два знака вопроса в начале строки, пробел и название файла. Т.е. собственно это готовый список измененных файлов, если учитывать мое допущение выше. Поэтому мне даже не нужно, еслия верно понимаю, ничего делать, кроме как итеративно отрезать два знака вопроса и пробел у каждого элемента list (я верно понимаю, что result_os - это list?) и вывести их список. Про сохранение куда-то речи нет, видимо, просто print.

Также я не понимаю, что также is_change = False и мне не нравится функция вывода. Поэтому я их перепишу.

Сильно подозреваю, что мой синтаксис мог бы быть короче в -3 раза, но не рискую переходить от линейного алгоритма к мартешке. Я никогдане писала на питоне.Кстати, не знаю, насколько тут вообще нужен break, но, поскольку мы ранее открыли read и я не понимаю, закроется ли он сам, оставлю.

Не уверена, что нужна последняя итерация с добавлением \n опять в конец элементов, только иначе это не будет красивым списком.

````
/#!/usr/bin/env python3

import os

bash_command = ["cd ~/netology/sysadm-homeworks", "git status -u --ignored --porcelain"]
result_os = os.popen(' && '.join(bash_command)).read()
    result_list = [result_os.split('\n')]
    printable = [result[3:] for result in result_list]
    b = '\n'
    for key in printable.keys()
        printable[key] = key + b
    print(printable)
    break
````

**3. Доработать скрипт выше так, чтобы он мог проверять не только локальный репозиторий в текущей директории, а также умел воспринимать путь к репозиторию, который мы передаём как входной параметр. Мы точно знаем, что начальство коварное и будет проверять работу этого скрипта в директориях, которые не являются локальными репозиториями.**

**Ответ:**

````
#!/usr/bin/env python3

import os

path_to_repository = sys.argv[1]
bash_command = []
bashcommand[0] = path_to_repository
bash_command[1] = 'git status -u --ignored --porcelain'
result_os = os.popen(' && '.join(bash_command)).read()
    result_list = [result_os.split('\n')]
    pre_printable = [result[3:] for result in result_list]
    printable = '\n'.join(pre_printable)
    print('Путь до репозитория: ', path_to_repository, '\nСписок измененных файлов:\n', printable)
    break
````

Я очень боюсь закопаться в мелких ошuбках и не успеть досдать задания, у меня осталось всего пара дней, чтобы не провалить весь курс. : ( Поэтому буду благодарна за отзыв, верный ли подход в целом и куда посмотреть, чтобы отладить все мои скрипты. Запускать их как файлики я стала по вышеуказанным причинам, обычно трачу на это несколько часов, но сейчас их просто нет((

**4. Наша команда разрабатывает несколько веб-сервисов, доступных по http. Мы точно знаем, что на их стенде нет никакой балансировки, кластеризации, за DNS прячется конкретный IP сервера, где установлен сервис. Проблема в том, что отдел, занимающийся нашей инфраструктурой очень часто меняет нам сервера, поэтому IP меняются примерно раз в неделю, при этом сервисы сохраняют за собой DNS имена. Это бы совсем никого не беспокоило, если бы несколько раз сервера не уезжали в такой сегмент сети нашей компании, который недоступен для разработчиков. Мы хотим написать скрипт, который опрашивает веб-сервисы, получает их IP, выводит информацию в стандартный вывод в виде: <URL сервиса> - <его IP>. Также, должна быть реализована возможность проверки текущего IP сервиса c его IP из предыдущей проверки. Если проверка будет провалена - оповестить об этом в стандартный вывод сообщением: [ERROR] <URL сервиса> IP mismatch: <старый IP> <Новый IP>. Будем считать, что наша разработка реализовала сервисы: drive.google.com, mail.google.com, google.com.**

**Ответ:**

Вроде более-менее я победила эту штуку. Да, ошибки сыпятся по 3 штуки (я думаю, цикл проверки на совпадение IP сделан неоптимально, стоило сравнивать попарно, но я уже боюсь переделывать). И да, красивый вывод я не осилила, пробовала много всякого разного, в т.ч. стороннего. Увы.

Закомментированные строки отражают мою попытку вывести уникальные ошибки, но я потерпела фиаско.

Первая ходка файла всегда дает ошибку, потому что там стоят 1 вместо IP. Но у меня все ходки давали ошибки, потому что IP во всех трех сервисах постоянно меняется))

````
#!/usr/bin/env python3

import os
import socket
import ast

file_list = os.popen("ls").read()
file_list = file_list.split('\n')
#print(file_list)
if 'server_IPs.txt' in file_list:
    pass
else:
    with open('server_IPs.txt', 'w') as file:
        file.write("{'drive.google.com': '1', 'mail.google.com': '1', 'google.com': '1'}")

with open('server_IPs.txt', 'r') as file:
    servers = file.read()
    #print(servers)
    type = type(servers)
    #print(type)
    dict = ast.literal_eval(servers)
    old_IPs = dict
    new_IPs = dict
#    errors = []
    for key_new, value_new in new_IPs.items():
        for key_old, value_old in old_IPs.items():
            value_new = [socket.gethostbyname(key_new)]
            new_IPs[key_new] = value_new
            if value_new != value_old:
                print('[ERROR] ', key_new, ' IP mismatch: ', value_old, ' - ', value_new, '\n')
#                error = "'[ERROR] ', key_new, ' IP mismatch: ', value_old, ' - ', value_new, '\n'"
#                errors.append(error)
#    unique_error_list = []
#    for i in errors:
#        if i not in errors:
#            unique_error_list.append(i)
#    print(unique_error_list)
#    error_message = "\n".join(str(x) for x in unique_error_list)
    print(new_IPs)
#    print(error_message)
    result = str(new_IPs)
    with open('server_IPs.txt', 'w') as old_file:
        old_file.write(result)
````