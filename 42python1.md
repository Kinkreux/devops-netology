Домашнее задание к занятию "4.2. Использование Python для решения типовых DevOps задач"
Марина Пустовит

**1. Есть скрипт:**

````
#!/usr/bin/env python3
a = 1
b = '2'
c = a + b
````

* Какое значение будет присвоено переменной c?
 * Нельзя сложить число (a автоматически присвоен int) и строку (b явно присвоена строка). Получим ошибку.

* Как получить для переменной c значение 12?
 * Нужно определить a как строку. Либо явно присвоить 1 в кавычках, либо явно присвоить переменной тип str. Строки конкатенируются, a + b даст 12.

* Как получить для переменной c значение 3?
 * Нужно определить b как int. Присвоить 2 без кавычек, и оно само станет int, или явно присвоить переменной тип int. Тогда a + b будет арифметической операцией и даст 3

**2. Мы устроились на работу в компанию, где раньше уже был DevOps Engineer. Он написал скрипт, позволяющий узнать, какие файлы модифицированы в репозитории, относительно локальных изменений. Этим скриптом недовольно начальство, потому что в его выводе есть не все изменённые файлы, а также непонятен полный путь к директории, где они находятся. Как можно доработать скрипт ниже, чтобы он исполнял требования вашего руководителя?**

````
#!/usr/bin/env python3

import os

bash_command = ["cd ~/netology/sysadm-homeworks", "git status"]
result_os = os.popen(' && '.join(bash_command)).read()
is_change = False
for result in result_os.split('\n'):
    if result.find('modified') != -1:
        prepare_result = result.replace('\tmodified:   ', '')
        print(prepare_result)
        break
        
````

**Ответ:**

Локальные изменения могут быть untracked, modified, staged и committed. Это то, что мы ещё не запушили в удаленный репозиторий (фактически все после последней синхронизации с удаленным репозиторием тем или иным способом).
Причем это могут быть целые ветки и семейства веток, а не только наш последний коммит или то, что случилось после него.  При этом имена веток и проч. неизвестны и могут быть любыми. Игнорируемые файлы тоже, по идее, к нам.
Но если я сейчас прпытаюсь написать команду, которая будет все это получать, то это будет уже что-то монструозное даже без питона и тянет на отдельную задачу со звездочкой.
Так что я допущу, что мы вот только что запушили и надо посмотреть только последние изменения без локальных коммитов и ограничусь добавлением к git status флагов, которые включат в список файлов неотслеживаемые и игнорируемые, а также вернет нормализованный вывод ("для скриптов", как утверждает ман).

Нормализованный вывод дает два знака вопроса в начале строки, пробел и название файла. Т.е. собственно это готовый список измененных файлов, если учитывать мое допущение выше. Поэтому мне даже не нужно, еслия верно понимаю, ничего делать, кроме как итеративно отрезать два знака вопроса и пробел у каждого элемента list (я верно понимаю, что result_os - это list?) и вывести их список. Про сохранение куда-то речи нет, видимо, просто print.

Также я не понимаю, что также is_change = False и мне не нравится функция вывода. Поэтому я их перепишу.

Сильно подозреваю, что мой синтаксис мог бы быть короче в -3 раза, но не рискую переходить от линейного алгоритма к мартешке. Я никогдане писала на питоне.Кстати, не знаю, насколько тут вообще нужен break, но, поскольку мы ранее открыли read и я не понимаю, закроется ли он сам, оставлю.

Не уверена, что нужна последняя итерация с добавлением \n опять в конец элементов, только иначе это не будет красивым списком.

**Переделала скрипт, у меня гит лежит по этому адресу, все отработало корректно, включая полный путь. И даже проигнорировало неизмененные файлы**

````
#!/usr/bin/env python3

import os

bash_command = ["cd ~/git/devops-netology", "git status -u --ignored --porcelain"]
result_os = os.popen(' && '.join(bash_command)).read()
result_list = result_os.split('\n')
printable = [result[3:] for result in result_list]
if len(printable) > 0:
    path = os.popen('pwd').read()
    print('Полный путь до директории: ', path, '\n', 'Измененные файлы:', '\n')
    for item in printable:
        if len(item) > 0:
            print(item)
    print('\n', 'Конец списка измененных файлов')
````

**3. Доработать скрипт выше так, чтобы он мог проверять не только локальный репозиторий в текущей директории, а также умел воспринимать путь к репозиторию, который мы передаём как входной параметр. Мы точно знаем, что начальство коварное и будет проверять работу этого скрипта в директориях, которые не являются локальными репозиториями.**

**Ответ:**

````
#!/usr/bin/env python3

import os
import sys

path_to_repository = sys.argv[1]
print(path_to_repository)
cd_and_path = 'cd ' + path_to_repository
bash_command = []
bash_command.insert(0, cd_and_path)
bash_command.insert(1, 'git status -u --ignored --porcelain')
print(bash_command)
result_os = os.popen(' && '.join(bash_command)).read()
result_list = result_os.split('\n')
printable = [result[3:] for result in result_list]
if len(printable) > 0:
    path = os.popen('pwd').read()
    print('Полный путь до директории: ', path, '\n', 'Измененные файлы:', '\n')
    for item in printable:
        if len(item) > 0:
            print(item)
    print('\n', 'Конец списка измененных файлов')
````

Переделала скрипт, должен работать. Испытывала на аргументе **~/git/devops-netology**, совсем относительный путь вводить не рисковала

**4. Наша команда разрабатывает несколько веб-сервисов, доступных по http. Мы точно знаем, что на их стенде нет никакой балансировки, кластеризации, за DNS прячется конкретный IP сервера, где установлен сервис. Проблема в том, что отдел, занимающийся нашей инфраструктурой очень часто меняет нам сервера, поэтому IP меняются примерно раз в неделю, при этом сервисы сохраняют за собой DNS имена. Это бы совсем никого не беспокоило, если бы несколько раз сервера не уезжали в такой сегмент сети нашей компании, который недоступен для разработчиков. Мы хотим написать скрипт, который опрашивает веб-сервисы, получает их IP, выводит информацию в стандартный вывод в виде: <URL сервиса> - <его IP>. Также, должна быть реализована возможность проверки текущего IP сервиса c его IP из предыдущей проверки. Если проверка будет провалена - оповестить об этом в стандартный вывод сообщением: [ERROR] <URL сервиса> IP mismatch: <старый IP> <Новый IP>. Будем считать, что наша разработка реализовала сервисы: drive.google.com, mail.google.com, google.com.**

**Ответ:**

Работает! Для ясности добавила статус "IP didn't change.", так понятнее.
Теоретически, 2 словаря тут лишние и можно было бы справиться с одним IPs, а не с old и new. Но я не буду трогать, раз работает.

````
#!/usr/bin/env python3

import os
import socket
import ast

file_list = os.popen("ls").read()
file_list = file_list.split('\n')
if 'server_IPs.txt' in file_list:
    pass
else:
    with open('server_IPs.txt', 'w') as file:
        file.write("{'drive.google.com': 1, 'mail.google.com': 2, 'google.com': 3}")

with open('server_IPs.txt', 'r') as file:
    servers = file.read()
    dict_new = ast.literal_eval(servers)
    old_IPs = dict_new
    new_IPs = dict_new
    key_list = old_IPs.keys()
    for key in key_list:
        temp = socket.gethostbyname(key)
        if temp != old_IPs[key]:
            print('[ERROR] ', key, ' IP mismatch: ', old_IPs[key], ' - ', temp, '\n')
        else:
                print(key, ' IP didn\'t change.\n')
        new_IPs[key] = temp
    result = str(new_IPs)
    with open('server_IPs.txt', 'w') as old_file:
        old_file.write(result)
````