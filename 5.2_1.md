# Домашнее задание к занятию "5.2. Применение принципов IaaC в работе с виртуальными машинами"

## Задача 1

- Опишите своими словами основные преимущества применения на практике IaaC паттернов.
- Какой из принципов IaaC является основополагающим?

Паттерны: CI, CD и CD. В моей компании есть CI/CD (без deployment), я много раз слышала слова Nexus, Gitlab CI и проч. Хотя работаю я дизайнером, но мне уже нынешний уровень понимания помогает в работе. В своем объяснении пытаюсь опираться на то, что понимаю в работе нашего окружения.

CI - Continiuos Integration. Вот у нас есть Джира, и каждая задача из Джиры в виде merge request может быть открыта как отдельный экземпляр с помощью кубернетиса. Когда ручное ревью пройдено и решено влить MR, он вливается в то, что является общим develop-стендом всех команд, которые работают над продуктом. Видимо, CI - это как раз тот этап, когда MR поставляется общий репозиторий и затем вливается в develop-стенд.

CD - Continious Delivery. В нашем случае это могут быть 2 вещи: во-первых, доступ к любому MR по отдельной ссылке, которая позволяет посмотреть его как мини-тестовый стенд. Это все происходит автоматически как результат отработки pipeline в эмуляции всего необходимого окружения, хотя я пока меньше понимаю, что такое pipeline, чем хотелось бы. И второй вариант, что может быть выражением CI - это сам develop-стенд, который пока что один, но на нем всегда автоматически собираются все MR, принятые всеми командами, которые пользуются общим gitlab

CD - Continious Deployment. В нашем случае он совершенно исключен, по крайней мере пока) У нас сейчас считается самым важным направление развития тестирования, как автоматизированного, так и ручного. Изменения хотят делать мелкими и частыми, чтобы максимально уйти от водопадной модели, и в то же время каждое изменение должно быть тщательнейшим образом оттестировано и принято целой кучей разного народа, бОльшая часть которого не имеет отношения к ИТ-подразделениям. Поэтому автоматизированная выкатка на бой исключена и вряд ли будет включена когда-либо.

Самый важный принцип - идемпотентность, то бишь когда каждый повторный запуск совершенно предсказуем и совпадает на 100% с результатами других запусков. Т.е. это предсказуемость, возведенная в принцип)

## Задача 2

- Чем Ansible выгодно отличается от других систем управление конфигурациями?
- Какой, на ваш взгляд, метод работы систем конфигурации более надёжный push или pull?

Ansible, судя по информации лектора, отличается низким порогом входа, а также возможностью работы поверх существующей системы ключей аутентификации (быстрее, чем делать отдельную). Может быть, плюсом является язык Python, потому что есть любители написать свои модули к используемым инструментам или использовать чужие модули, а это гораздо проще и спокойнее делать, имея возможность понять, как работает их код (тут я не уверена, могу только предполагать). Кроме того, конфигурации пишутся на yaml, который используется очень широко. Якраем уха слышала, что у нас конфигурации тоже пишутся на yaml. Само по себе это ничего не значит, но возможно,что у нас тоже используют Ansible. Кстати, в нашем случае низкий порог входа является плюсом, потому что простые файлы конфигурации могут писать сами разработчики по аналогии, а devops - просто проверять.

Судя по тому, что сложные системы используют оба, наверно, надежднее всего применять оба.

В пользу push можно указать: отображение ошибок в консоли, т.е. некоторая интерактивность, а также расчет на отказоустойчивость скорее центральной системы, чем распределенных. Если какой-то удаленный узел недоступен, то мы можем продолжать пушить на него либо разбираться с проблемой, увидев ее в мониторинге, потому что инициатива находится на стороне центра.

В пользу pull можно сказать, что мы не должны, наверно, узнавать о проблемах с серверами в процессе работы с Ansible, скорее наши коллеги должны видеть это оперативно в системах мониторинга. В то же время, удаленные узлы могут быть более самостоятельны и иметь какие-то сценарии на случай, например, если мы запросили конфигурацию, а центральные сервера с ней временно недоступны. Это я уже выдумываю, конечно.

Наверно, ясама использовала бы скорее push, а pull в дополнение к нему. Остается только догадываться, почему авторы альтенративных систем (кроме Ansible и Terraform) сделал выбор как раз в сторону pull. Видимо, они знают что-то, чего не знаю я. Может быть, такова специфика архитектуры, которую они выбрали, потому что каждый инструмент для своей задачи, значит инструменты все по определению разные.

## Задача 3

Установить на личный компьютер:

- VirtualBox
- Vagrant
- Ansible

*Приложить вывод команд установленных версий каждой из программ, оформленный в markdown.*

VurtualBox и Vagrant у меня уже стоят, ставлю Ansible. Не совсем ясно, что именно нужно привести в качестве ответа, но я попробую:

VirtualBox

```
6.1.0r135406
```

Vagrant

Я скачала последнюю версию вагранта с официального сайта и попыталась ее установить, но и так и сяк система сообщала, что установлена последняя версия. Вывод самой версии это опровергает, но я ничего не могу поделать.

```
Installed Version: 2.2.10
Latest Version: 2.2.19
 
To upgrade to the latest version, visit the downloads page and
download and install the latest version of Vagrant from the URL
below:

  https://www.vagrantup.com/downloads.html

If you're curious what changed in the latest release, view the
CHANGELOG below:

  https://github.com/hashicorp/vagrant/blob/v2.2.19/CHANGELOG.md
```

Ansible

```
ansible [core 2.12.4]
  config file = /etc/ansible/ansible.cfg
  configured module search path = ['/home/kinkreu/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /usr/lib/python3/dist-packages/ansible
  ansible collection location = /home/kinkreu/.ansible/collections:/usr/share/ansible/collections
  executable location = /usr/bin/ansible
  python version = 3.8.10 (default, Mar 15 2022, 12:22:08) [GCC 9.4.0]
  jinja version = 2.10.1
  libyaml = True
```

## Задача 4 (*)

*Не делала*

Воспроизвести практическую часть лекции самостоятельно.

- Создать виртуальную машину.
- Зайти внутрь ВМ, убедиться, что Docker установлен с помощью команды
```
docker ps
```